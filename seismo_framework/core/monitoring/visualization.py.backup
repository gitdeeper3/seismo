"""
Visualization tools for monitoring data.
"""
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from typing import Dict, List, Optional, Any, Tuple
import logging
from datetime import datetime, timedelta
import seaborn as sns
import plotly.graph_objects as go
from plotly.subplots import make_subplots
logger = logging.getLogger(__name__)
class MonitoringVisualizer:
    """
    Visualization tools for monitoring data.
    """
    def __init__(self, style: str = 'seaborn'):
        self.style = style
        self._setup_plotting_style()
    def _setup_plotting_style(self):
        """Setup plotting style."""
        if self.style == 'seaborn':
            sns.set_style("whitegrid")
            sns.set_palette("husl")
            plt.rcParams['figure.figsize'] = [12, 8]
            plt.rcParams['font.size'] = 10
        elif self.style == 'plotly':
            # Plotly setup
            self.plotly_template = 'plotly_white'
        else:
            plt.style.use('default')
    def plot_parameter_timeseries(self, historical_data: pd.DataFrame,
                                 parameter_names: List[str],
                                 hours: int = 24,
                                 save_path: Optional[str] = None) -> plt.Figure:
        """
        Plot time series of parameters.
        Args:
            historical_data: Historical monitoring data
            parameter_names: List of parameter names to plot
            hours: Time window in hours
            save_path: Optional path to save figure
        Returns:
            Matplotlib figure
        """
        if historical_data.empty:
            logger.warning("No historical data to plot")
            return None
        # Filter by time window
        cutoff = datetime.now() - timedelta(hours=hours)
        mask = pd.to_datetime(historical_data['timestamp']) > cutoff
        plot_data = historical_data[mask].copy()
        if plot_data.empty:
            logger.warning("No data in specified time window")
            return None
        # Create figure
        n_params = len(parameter_names)
        fig, axes = plt.subplots(n_params, 1, figsize=(14, 3*n_params), sharex=True)
        if n_params == 1:
            axes = [axes]
        # Plot each parameter
        for idx, param_name in enumerate(parameter_names):
            ax = axes[idx]
            # Get parameter column
            param_col = f'param_{param_name}'
            if param_col not in plot_data.columns:
                logger.warning(f"Parameter {param_name} not found in data")
                continue
            # Convert timestamps
            timestamps = pd.to_datetime(plot_data['timestamp'])
            # Plot parameter values
            ax.plot(timestamps, plot_data[param_col], 
                   label=param_name, linewidth=2, alpha=0.8)
            # Add uncertainty if available
            unc_col = f'unc_{param_name}'
            if unc_col in plot_data.columns:
                y = plot_data[param_col]
                y_unc = plot_data[unc_col]
                ax.fill_between(timestamps, y - y_unc, y + y_unc,
                               alpha=0.2, label='Uncertainty')
            # Formatting
            ax.set_ylabel(param_name.replace('_', ' ').title(), fontsize=11)
            ax.grid(True, alpha=0.3)
            ax.legend(loc='upper right')
            # Add threshold lines
            ax.axhline(y=0.7, color='red', linestyle='--', alpha=0.5, label='Warning')
            ax.axhline(y=0.5, color='orange', linestyle='--', alpha=0.5, label='Watch')
            ax.axhline(y=0.3, color='yellow', linestyle='--', alpha=0.5, label='Elevated')
        # Format x-axis
        axes[-1].set_xlabel('Time', fontsize=11)
        axes[-1].xaxis.set_major_formatter(mdates.DateFormatter('%H:%M'))
        axes[-1].xaxis.set_major_locator(mdates.HourLocator(interval=max(1, hours//12)))
        plt.suptitle(f'Parameter Time Series (Last {hours} hours)', fontsize=14, y=0.98)
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            logger.info(f"Figure saved to {save_path}")
        return fig
    def plot_integrated_score(self, historical_data: pd.DataFrame,
                             hours: int = 24,
                             save_path: Optional[str] = None) -> plt.Figure:
        """
        Plot integrated score over time.
        Args:
            historical_data: Historical monitoring data
            hours: Time window in hours
            save_path: Optional path to save figure
        Returns:
            Matplotlib figure
        """
        if historical_data.empty:
            logger.warning("No historical data to plot")
            return None
        # Filter by time window
        cutoff = datetime.now() - timedelta(hours=hours)
        mask = pd.to_datetime(historical_data['timestamp']) > cutoff
        plot_data = historical_data[mask].copy()
        if plot_data.empty:
            logger.warning("No data in specified time window")
            return None
        fig, axes = plt.subplots(2, 1, figsize=(14, 10))
        # Convert timestamps
        timestamps = pd.to_datetime(plot_data['timestamp'])
        # Top plot: Integrated score with confidence
        ax1 = axes[0]
        # Plot integrated score
        ax1.plot(timestamps, plot_data['integrated_score'], 
                label='Integrated Score', linewidth=3, color='darkblue', alpha=0.8)
        # Add confidence interval if available
        if 'confidence' in plot_data.columns:
            y = plot_data['integrated_score']
            conf = plot_data['confidence']
            ax1.fill_between(timestamps, y - (1-conf)/2, y + (1-conf)/2,
                           alpha=0.2, color='blue', label='Confidence')
        # Add alert level regions
        ax1.axhspan(0.7, 1.0, alpha=0.1, color='red', label='Warning Zone')
        ax1.axhspan(0.5, 0.7, alpha=0.1, color='orange', label='Watch Zone')
        ax1.axhspan(0.3, 0.5, alpha=0.1, color='yellow', label='Elevated Zone')
        ax1.axhspan(0.0, 0.3, alpha=0.1, color='green', label='Normal Zone')
        # Formatting
        ax1.set_ylabel('Integrated Score', fontsize=12)
        ax1.set_ylim(0, 1)
        ax1.grid(True, alpha=0.3)
        ax1.legend(loc='upper right')
        ax1.set_title(f'Integrated Volcanic Activity Score (Last {hours} hours)', fontsize=14)
        # Bottom plot: Alert level
        ax2 = axes[1]
        # Convert alert levels to numeric for plotting
        alert_levels = plot_data['alert_level'].map({
            'normal': 0,
            'elevated': 1,
            'watch': 2,
            'warning': 3
        })
        # Create stepped plot for alert levels
        ax2.step(timestamps, alert_levels, where='post', 
                linewidth=2, color='darkred', alpha=0.8)
        # Formatting
        ax2.set_yticks([0, 1, 2, 3])
        ax2.set_yticklabels(['Normal', 'Elevated', 'Watch', 'Warning'])
        ax2.set_ylabel('Alert Level', fontsize=12)
        ax2.set_ylim(-0.5, 3.5)
        ax2.grid(True, alpha=0.3)
        # Format x-axis
        ax2.xaxis.set_major_formatter(mdates.DateFormatter('%H:%M\n%Y-%m-%d'))
        ax2.xaxis.set_major_locator(mdates.HourLocator(interval=max(1, hours//6)))
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            logger.info(f"Figure saved to {save_path}")
        return fig
    def plot_parameter_correlations(self, historical_data: pd.DataFrame,
                                   save_path: Optional[str] = None) -> plt.Figure:
        """
        Plot parameter correlation matrix.
        Args:
            historical_data: Historical monitoring data
            save_path: Optional path to save figure
        Returns:
            Matplotlib figure
        """
        if historical_data.empty:
            logger.warning("No historical data to plot")
            return None
        # Extract parameter columns
        param_cols = [col for col in historical_data.columns 
                     if col.startswith('param_')]
        if len(param_cols) < 2:
            logger.warning("Insufficient parameters for correlation plot")
            return None
        # Create parameter matrix
        param_data = historical_data[param_cols].copy()
        param_names = [col.replace('param_', '') for col in param_cols]
        param_data.columns = param_names
        # Calculate correlation matrix
        corr_matrix = param_data.corr()
        # Create figure
        fig, ax = plt.subplots(figsize=(10, 8))
        # Create heatmap
        im = ax.imshow(corr_matrix, cmap='RdBu_r', vmin=-1, vmax=1)
        # Add correlation values
        for i in range(len(param_names)):
            for j in range(len(param_names)):
                value = corr_matrix.iloc[i, j]
                color = 'white' if abs(value) > 0.5 else 'black'
                ax.text(j, i, f'{value:.2f}', 
                       ha='center', va='center', 
                       color=color, fontsize=9)
        # Formatting
        ax.set_xticks(range(len(param_names)))
        ax.set_yticks(range(len(param_names)))
        ax.set_xticklabels(param_names, rotation=45, ha='right')
        ax.set_yticklabels(param_names)
        ax.set_title('Parameter Correlation Matrix', fontsize=14, pad=20)
        # Add colorbar
        plt.colorbar(im, ax=ax, label='Correlation Coefficient')
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            logger.info(f"Figure saved to {save_path}")
        return fig
    def plot_parameter_histograms(self, historical_data: pd.DataFrame,
                                 save_path: Optional[str] = None) -> plt.Figure:
        """
        Plot histograms of parameter distributions.
        Args:
            historical_data: Historical monitoring data
            save_path: Optional path to save figure
        Returns:
            Matplotlib figure
        """
        if historical_data.empty:
            logger.warning("No historical data to plot")
            return None
        # Extract parameter columns
        param_cols = [col for col in historical_data.columns 
                     if col.startswith('param_')]
        if not param_cols:
            logger.warning("No parameter data found")
            return None
        # Create subplots
        n_params = len(param_cols)
        n_cols = min(4, n_params)
        n_rows = (n_params + n_cols - 1) // n_cols
        fig, axes = plt.subplots(n_rows, n_cols, figsize=(4*n_cols, 3*n_rows))
        if n_params == 1:
            axes = np.array([axes])
        axes = axes.flatten()
        # Plot each parameter
        for idx, param_col in enumerate(param_cols):
            ax = axes[idx]
            param_name = param_col.replace('param_', '')
            # Get data
            data = historical_data[param_col].dropna()
            if len(data) > 0:
                # Plot histogram
                ax.hist(data, bins=20, alpha=0.7, edgecolor='black',
                       density=True)
                # Add KDE
                from scipy import stats
                kde = stats.gaussian_kde(data)
                x_range = np.linspace(0, 1, 100)
                ax.plot(x_range, kde(x_range), 'r-', linewidth=2)
                # Add mean and std lines
                mean_val = data.mean()
                std_val = data.std()
                ax.axvline(mean_val, color='green', linestyle='--', 
                          linewidth=2, label=f'Mean: {mean_val:.2f}')
                ax.axvline(mean_val - std_val, color='orange', 
                          linestyle=':', linewidth=1)
                ax.axvline(mean_val + std_val, color='orange', 
                          linestyle=':', linewidth=1)
                # Add threshold lines
                ax.axvline(0.7, color='red', linestyle='-', 
                          alpha=0.3, linewidth=1)
                ax.axvline(0.5, color='orange', linestyle='-', 
                          alpha=0.3, linewidth=1)
                ax.axvline(0.3, color='yellow', linestyle='-', 
                          alpha=0.3, linewidth=1)
                # Formatting
                ax.set_xlim(0, 1)
                ax.set_xlabel('Value')
                ax.set_ylabel('Density')
                ax.set_title(f'{param_name.replace("_", " ").title()}', 
                           fontsize=11)
                ax.legend(fontsize=8)
                ax.grid(True, alpha=0.3)
        # Hide unused subplots
        for idx in range(len(param_cols), len(axes)):
            axes[idx].axis('off')
        plt.suptitle('Parameter Value Distributions', fontsize=14, y=0.98)
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            logger.info(f"Figure saved to {save_path}")
        return fig
    def create_interactive_dashboard(self, historical_data: pd.DataFrame,
                                    current_state: Dict[str, Any]) -> go.Figure:
        """
        Create interactive Plotly dashboard.
        Args:
            historical_data: Historical monitoring data
            current_state: Current monitoring state
        Returns:
            Plotly figure
        """
        if historical_data.empty:
            logger.warning("No historical data for dashboard")
            return None
        # Create subplots
        fig = make_subplots(
            rows=3, cols=2,
            subplot_titles=('Integrated Score Timeline', 'Parameter Values',
                          'Alert Level History', 'Parameter Correlations',
                          'Current Status', 'Parameter Distributions'),
            specs=[[{'type': 'scatter'}, {'type': 'scatter'}],
                   [{'type': 'scatter'}, {'type': 'heatmap'}],
                   [{'type': 'indicator', 'colspan': 2}, None]],
            vertical_spacing=0.12,
            horizontal_spacing=0.1
        )
        # 1. Integrated Score Timeline
        if 'integrated_score' in historical_data.columns:
            timestamps = pd.to_datetime(historical_data['timestamp'])
            fig.add_trace(
                go.Scatter(
                    x=timestamps,
                    y=historical_data['integrated_score'],
                    mode='lines',
                    name='Integrated Score',
                    line=dict(color='blue', width=2),
                    fill='tozeroy',
                    fillcolor='rgba(0, 0, 255, 0.1)'
                ),
                row=1, col=1
            )
        # 2. Parameter Values (last 24 hours)
        param_cols = [col for col in historical_data.columns 
                     if col.startswith('param_')]
        if param_cols:
            # Get last 24 hours
            cutoff = datetime.now() - timedelta(hours=24)
            mask = pd.to_datetime(historical_data['timestamp']) > cutoff
            recent_data = historical_data[mask]
            if not recent_data.empty:
                timestamps = pd.to_datetime(recent_data['timestamp'])
                for param_col in param_cols[:5]:  # Limit to 5 parameters
                    param_name = param_col.replace('param_', '')
                    fig.add_trace(
                        go.Scatter(
                            x=timestamps,
                            y=recent_data[param_col],
                            mode='lines',
                            name=param_name,
                            visible='legendonly'  # Hide by default
                        ),
                        row=1, col=2
                    )
        # 3. Alert Level History
        if 'alert_level' in historical_data.columns:
            # Convert alert levels to numeric
            alert_mapping = {'normal': 0, 'elevated': 1, 'watch': 2, 'warning': 3}
            alert_numeric = historical_data['alert_level'].map(alert_mapping)
            fig.add_trace(
                go.Scatter(
                    x=pd.to_datetime(historical_data['timestamp']),
                    y=alert_numeric,
                    mode='lines',
                    name='Alert Level',
                    line=dict(color='red', width=2)
                ),
                row=2, col=1
            )
            # Add alert level annotations
            fig.update_yaxes(
                tickvals=list(alert_mapping.values()),
                ticktext=list(alert_mapping.keys()),
                row=2, col=1
            )
        # 4. Parameter Correlations
        if len(param_cols) >= 2:
            param_data = historical_data[param_cols].copy()
            param_names = [col.replace('param_', '') for col in param_cols]
            param_data.columns = param_names
            corr_matrix = param_data.corr()
            fig.add_trace(
                go.Heatmap(
                    z=corr_matrix.values,
                    x=param_names,
                    y=param_names,
                    colorscale='RdBu',
                    zmin=-1,
                    zmax=1,
                    colorbar=dict(title='Correlation')
                ),
                row=2, col=2
            )
        # 5. Current Status Gauge
        if current_state:
            recent_data = current_state.get('recent_data', {})
            integration = recent_data.get('integration', {})
            score = integration.get('integrated_score', 0.5)
            fig.add_trace(
                go.Indicator(
                    mode="gauge+number",
                    value=score * 100,
                    title={'text': "Current Risk Level"},
                    domain={'row': 3, 'column': 1},
                    gauge={
                        'axis': {'range': [0, 100]},
                        'bar': {'color': "darkblue"},
                        'steps': [
                            {'range': [0, 30], 'color': "green"},
                            {'range': [30, 50], 'color': "yellow"},
                            {'range': [50, 70], 'color': "orange"},
                            {'range': [70, 100], 'color': "red"}
                        ],
                        'threshold': {
                            'line': {'color': "black", 'width': 4},
                            'thickness': 0.75,
                            'value': 70
                        }
                    }
                ),
                row=3, col=1
            )
        # Update layout
        fig.update_layout(
            height=900,
            title_text="Volcano Monitoring Dashboard",
            showlegend=True,
            template=self.plotly_template
        )
        return fig
    def plot_alert_timeline(self, alerts: List[Dict[str, Any]],
                           save_path: Optional[str] = None) -> plt.Figure:
        """
        Plot alert timeline.
        Args:
            alerts: List of alert dictionaries
            save_path: Optional path to save figure
        Returns:
            Matplotlib figure
        """
        if not alerts:
            logger.warning("No alerts to plot")
            return None
        # Convert to DataFrame
        alerts_df = pd.DataFrame(alerts)
        if alerts_df.empty:
            return None
        fig, ax = plt.subplots(figsize=(14, 6))
        # Convert timestamps
        timestamps = pd.to_datetime(alerts_df['timestamp'])
        # Map alert levels to numeric values
        alert_levels = alerts_df['alert_level'].map({
            'normal': 0,
            'elevated': 1,
            'watch': 2,
            'warning': 3
        })
        # Create stepped timeline
        ax.step(timestamps, alert_levels, where='post', 
                linewidth=3, color='darkred', alpha=0.8)
        # Add markers for alert changes
        change_indices = np.where(np.diff(alert_levels) != 0)[0]
        for idx in change_indices:
            ax.plot(timestamps.iloc[idx+1], alert_levels.iloc[idx+1], 
                   'o', markersize=10, color='red', alpha=0.7)
        # Formatting
        ax.set_yticks([0, 1, 2, 3])
        ax.set_yticklabels(['Normal', 'Elevated', 'Watch', 'Warning'])
        ax.set_ylabel('Alert Level', fontsize=12)
        ax.set_ylim(-0.5, 3.5)
        # Format x-axis
        ax.xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m-%d\n%H:%M'))
        # Add grid
        ax.grid(True, alpha=0.3)
        # Add title
        ax.set_title('Alert Level Timeline', fontsize=14, pad=20)
        # Add annotations for warning alerts
        warning_mask = alerts_df['alert_level'] == 'warning'
        warning_times = timestamps[warning_mask]
        for time in warning_times:
            ax.axvline(x=time, color='red', linestyle='--', alpha=0.5, linewidth=1)
        plt.tight_layout()
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            logger.info(f"Figure saved to {save_path}")
        return fig
def create_monitoring_report(historical_data: pd.DataFrame,
                            current_state: Dict[str, Any],
                            output_dir: str = './reports'):
    """
    Create comprehensive monitoring report with visualizations.
    Args:
        historical_data: Historical monitoring data
        current_state: Current monitoring state
        output_dir: Output directory for reports
    """
    import os
    from datetime import datetime
    # Create output directory
    os.makedirs(output_dir, exist_ok=True)
    # Create timestamp for filenames
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    # Initialize visualizer
    visualizer = MonitoringVisualizer()
    # Generate all plots
    plots = {}
    try:
        # 1. Integrated score plot
        plots['integrated_score'] = visualizer.plot_integrated_score(
            historical_data, hours=24,
            save_path=os.path.join(output_dir, f'integrated_score_{timestamp}.png')
        )
        # 2. Parameter time series
        param_cols = [col for col in historical_data.columns 
                     if col.startswith('param_')]
        if param_cols:
            param_names = [col.replace('param_', '') for col in param_cols[:4]]  # First 4
            plots['parameter_series'] = visualizer.plot_parameter_timeseries(
                historical_data, param_names, hours=24,
                save_path=os.path.join(output_dir, f'parameter_series_{timestamp}.png')
            )
        # 3. Correlation matrix
        plots['correlations'] = visualizer.plot_parameter_correlations(
            historical_data,
            save_path=os.path.join(output_dir, f'correlations_{timestamp}.png')
        )
        # 4. Histograms
        plots['histograms'] = visualizer.plot_parameter_histograms(
            historical_data,
            save_path=os.path.join(output_dir, f'histograms_{timestamp}.png')
        )
        logger.info(f"Monitoring report created in {output_dir}")
    except Exception as e:
        logger.error(f"Error creating monitoring report: {e}")
    return plots